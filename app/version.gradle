apply plugin: 'org.ajoberstar.grgit'

/**
 * See https://gist.github.com/r0adkll/894322f31f96ac6809d4
 */

import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

def versionFile = file("../version.json")
def versionJSON = getJSON(versionFile)
def versionCode = versionJSON.versionCode
def versionName = getVersionName(versionJSON)

def getJSON(file) {
    return new JsonSlurper().parseText(file.text)
}

def getVersionName(versionJSON) {
    // Expose as extra properties at project level
    return "v${versionJSON.major}.${versionJSON.minor}.${versionJSON.patch}"
}

ext.versionCode = versionCode
ext.versionName = versionName

task prepareReleaseBranch(dependsOn: check) {
    description = "Creates release branch and bumps up version number for: ${project.version}"
    group = 'release'

    doLast {
        // Ensure release starts from develop branch

        if (!grgit.branch.getCurrent().getName().equals("develop")) {
            println "[!!] You must branch releases from develop"
            //throw new GradleException("You must branch releases from develop")
        }
        println "Preparing release for existing version name" + versionName
        println "Preparing release for existing version code" + versionCode
        // Ensure our working copy is clean first
        if (!grgit.status().isClean()) {
            println "[!!] You must NOT have any changes in your working copy"
            //throw new GradleException("You must NOT have any changes in your working copy")
        }

        // Update version code
        versionJSON.patch += 1
        versionJSON.versionCode += 1
        versionCode = versionJSON.versionCode
        versionName = getVersionName(versionJSON)
        versionFile.write(new JsonBuilder(versionJSON).toPrettyString())

        // Apply version code to all variants. This is necessary
        // so when we build the APK, it gets the updated values
        android.applicationVariants.all { variant ->
            variant.mergedFlavor.versionCode = versionCode
            variant.mergedFlavor.versionName = "${variant.name}-${versionName}"
        }

        // Checkout new release branch
        grgit.checkout(branch: "release/${versionName}", createBranch: true)

        // Add changes
        def changes = grgit.status().unstaged.getAllChanges()
        grgit.add(update: true, patterns: changes)

        // Commit
        grgit.commit(message: "Version updated for release ${versionName}")

    }
}

task pushReleaseBrach << {
    description = "Pushes release branch, creates tag with changelo.md content and opens pre-release PR: ${project.version}"
    group = 'release'

    // Make sure only changelog.md has changed
    def changes = grgit.status().unstaged.getAllChanges()
    if (changes.size() != 1 || changes[0] != "CHANGELOG.md") {
        throw new GradleException("[!!] The only change at this point should be on CHANGELOG.md. Please review release process at: https://github.com/novoda/piriform-ccleaner/wiki/Release-Process-(2017)")
    }

    // Commit changelog.md & push release branch
    grgit.add(update: true, patterns: changes)
    grgit.commit(message: "Changelog updated for release ${versionName}")
    grgit.push()


    // Create tag / Draft release

//    String changelog = extractChangelog()
//    grgit.tag.add {
//        name = "${versionName}"
//        message = "Release ${versionName}\n$changelog"
//    }
}

private String extractChangelog() {
    String fullChangelog = rootProject.file('CHANGELOG.md').text

    def latestChangelog = (fullChangelog =~ /\## Version ${project.versionName}.*\n-*([\s\S]*?)\## Version.*\n-*/)

    if (latestChangelog.size() > 0) {
        return latestChangelog[0][1].trim()
    }

    def firstChangelog = (fullChangelog =~ /\[## Version ${project.versionName}.*\n-*([\s\S]*)/)

    if (firstChangelog.size() > 0) {
        return firstChangelog[0][1].trim()
    }
    throw new GradleException("No changelog found for version ${project.versionName}")
}

task printChangelog {
    group = 'help'
    description = "Print the provisional changelog for version ${project.versionName}"
    doLast {
        println "\nChangelog for version $project.versionName:\n${extractChangelog()}\n"
    }
}

